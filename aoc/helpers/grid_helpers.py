# Docstrings are generated by chatgpt (im lazy)
from collections import deque


def check_bounds(array, x, y):
    """
    Checks if the given coordinates are within the bounds of the 2D array.

    Args:
        array (list of lists): The 2D grid.
        x (int): Row index.
        y (int): Column index.

    Returns:
        bool: True if the coordinates are within bounds, False otherwise.
    """
    return 0 <= x < len(array) and 0 <= y < len(array[0])


def is_valid(array, x, y, visited, blockade="#"):
    """
    Determines if a cell is valid for traversal.

    Args:
        array (list of lists): The 2D grid.
        x (int): Row index.
        y (int): Column index.
        visited (set): Set of visited cells.
        blockade (str): Character representing blocked cells.

    Returns:
        bool: True if the cell can be traversed, False otherwise.
    """
    return (
        check_bounds(array, x, y) and (x, y) not in visited and array[x][y] != blockade
    )


def find_index(array, target_value):
    """
    Finds all occurrences of a target value in a 2D grid.

    Args:
        array (list of lists): The 2D grid.
        target_value (any): Value to find in the grid.

    Returns:
        list of tuples: Coordinates of all cells matching the target value.
    """
    starts = []
    for x, line in enumerate(array):
        for y, value in enumerate(line):
            if value == target_value:
                starts.append((x, y))
    return starts


def print_path(field, path=[]):
    """
    Marks a path on the grid, prints the grid, and resets the grid.

    Args:
        field (list of lists): The 2D grid.
        path (list of tuples, optional): List of coordinates representing the path. Defaults to [].

    Returns:
        None
    """
    for step in path:
        x, y = step
        field[x][y] = "O"
    for line in field:
        print("".join(line))
    for step in path:
        x, y = step
        field[x][y] = "."
    print()


def bfs(field, start_x, start_y, finish_x, finish_y):
    """
    Performs Breadth-First Search (BFS) to find a path between two points.

    Args:
        field (list of lists): The 2D grid.
        start_x (int): Starting row index.
        start_y (int): Starting column index.
        finish_x (int): Target row index.
        finish_y (int): Target column index.

    Returns:
        tuple: (bool, list) - A boolean indicating success and the path taken.
    """
    queue = deque([(start_x, start_y, [(start_x, start_y)])])
    visited = set()
    dirs = [(0, 1), (-1, 0), (0, -1), (1, 0)]

    while queue:
        x, y, path = queue.popleft()
        if (x, y) == (finish_x, finish_y):
            return True, path
        if (x, y) in visited:
            continue
        visited.add((x, y))
        for dx, dy in dirs:
            new_x, new_y = x + dx, y + dy
            if is_valid(field, new_x, new_y, visited):
                queue.append((new_x, new_y, path + [(new_x, new_y)]))
    return False, path


def dfs(grid, startX, startY, directions):
    """
    Performs Depth-First Search (DFS) to find a connected region and its perimeter.

    Args:
        grid (list of lists): The 2D grid.
        startX (int): Starting row index.
        startY (int): Starting column index.
        directions (list of tuples): List of movement directions.

    Returns:
        tuple: (list, list) - The connected region and the perimeter cells.
    """
    region = []
    perimeters = []
    stack = [(startX, startY)]

    while stack:
        x, y = stack.pop()
        if (x, y) in region:
            continue
        region.append((x, y))
        for dx, dy in directions:
            next_x, next_y = x + dx, y + dy
            if is_valid(grid, next_x, next_y, region):
                stack.append((next_x, next_y))
            else:
                if (next_x, next_y) not in region:
                    perimeters.append((x, y))
    return region, perimeters
